## 面向對象編程入門

面向對象編程係一種非常流行嘅**編程範式**（programming paradigm），所謂編程範式就係**程式設計嘅方法論**，簡單咁講就係程式員對程式嘅認知同理解以及佢哋編寫代碼嘅方式。

喺前面嘅課程中，我哋講過「**程式係指令嘅集合**」，運行程式時，程式中嘅語句會變成一條或多條指令，然後由CPU（中央處理器）去執行。為咗簡化程式嘅設計，我哋又講到咗函數，**將相對獨立且經常重複使用嘅代碼放置到函數中**，喺需要使用呢啲代碼嘅時候調用函數即可。如果一個函數嘅功能過於複雜同臃腫，我哋又可以進一步**將函數進一步拆分為多個子函數**嚟降低系統嘅複雜性。

唔知大家係咪發現，編程其實係寫程式嘅人按照計算機嘅工作方式透過代碼控制機器完成任務。但係，計算機嘅工作方式同人類正常嘅思維模式係唔同嘅，如果編程就必須拋棄人類正常嘅思維方式去迎合計算機，編程嘅樂趣就少咗好多。呢度，我想講嘅並唔係我哋唔可以按照計算機嘅工作方式去編寫代碼，但係當我哋需要開發一個複雜嘅系統時，呢種方式會令代碼過於複雜，從而導致開發同維護工作都變得舉步維艱。

隨著軟件複雜性嘅增加，編寫正確可靠嘅代碼會變成咗一項極為艱巨嘅任務，呢亦都係好多人都堅信「軟件開發係人類改造世界所有活動中最為複雜嘅活動」嘅原因。點樣用程式描述複雜系統同解決複雜問題，就成為咗所有程式員必須要思考同直面嘅問題。誕生於上世紀70年代嘅 Smalltalk 語言令軟件開發者睇到咗希望，因為佢引入咗一種新嘅編程範式叫面向對象編程。喺面向對象編程嘅世界裡，程式中嘅**數據同操作數據嘅函數係一個邏輯上嘅整體**，我哋稱之為**對象**，**對象可以接收消息**，解決問題嘅方法就係**創建對象並向對象發出各種各樣嘅消息**；透過消息傳遞，程式中嘅多個對象可以協同工作，咁樣就能構造出複雜嘅系統並解決現實中嘅問題。當然，面向對象編程嘅雛形還可以向前追溯到更早期嘅Simula語言，但呢並唔係我哋要討論嘅重點。

> **說明：** 今日我哋使用嘅好多高級程式設計語言都支持面向對象編程，但係面向對象編程都唔係解決軟件開發中所有問題嘅「銀彈」，或者話喺軟件開發呢個行業目前仲冇所謂嘅「銀彈」。關於呢個問題，大家可以參考 IBM360 系統之父弗雷德里克·布魯克斯所發表嘅論文《冇銀彈：軟件工程嘅本質性與附屬性工作》或軟件工程嘅經典著作《人月神話》一書。

### 類同對象

如果用一句話嚟概括面向對象編程，我認為下面嘅講法係相當精辟同準確嘅。

> **面向對象編程**：將一組數據同處理數據嘅方法組成**對象**，將行為相同嘅對象歸納為**類**，透過**封裝**隱藏對象嘅內部細節，透過**繼承**實現類嘅特化同泛化，透過**多態**實現基於對象類型嘅動態分派。

呢句話對初學者嚟講可能唔係咁容易理解，但我可以先為大家圈出幾個關鍵詞：**對象**（object）、**類**（class）、**封裝**（encapsulation）、**繼承**（inheritance）、**多態**（polymorphism）。

我哋先講下類同對象呢兩個詞。喺面向對象編程中，**類係一個抽象嘅概念，對象係一個具體嘅概念**。我哋將同一類對象嘅共同特徵抽取出來就係一個類，比如我哋經常講嘅人類，呢係一個抽象概念，而我哋每個人就係人類呢個抽象概念下嘅實實在在嘅存在，亦即係一個對象。簡而言之，**類係對象嘅藍圖同模板，對象係類嘅實例，係可以接受消息嘅實體**。

喺面向對象編程嘅世界中，**一切皆為對象**，**對象都有屬性同行為**，**每個對象都係獨一無二嘅**，而且**對象一定屬於某個類**。對象嘅屬性係對象嘅靜態特徵，對象嘅行為係對象嘅動態特徵。按照上面嘅講法，如果我哋將擁有共同特徵嘅對象嘅屬性同行為都抽取出來，就可以定義出一個類。

<img src="res/day18/20210731182741.png" width="75%">

### 定義類

喺 Python 語言中，我哋可以使用`class`關鍵字加上類名嚟定義類，透過縮進我哋可以確定類嘅代碼塊，就好似定義函數咁樣。喺類嘅代碼塊中，我哋需要寫一啲函數，我哋講過類係一個抽象概念，咁呢啲函數就係我哋對一類對象共同嘅動態特徵嘅提取。寫喺類裡面嘅函數我哋通常稱之為**方法**，方法就係對象嘅行為，亦即係對象可以接收嘅消息。方法嘅第一個參數通常都係`self`，佢代表咗接收呢個消息嘅對象本身。

```python
class Student:

    def study(self, course_name):
        print(f'學生正在學習{course_name}.')

    def play(self):
        print(f'學生正在玩遊戲.')
```

### 創建同使用對象

喺我哋定義好一個類之後，可以使用構造器語法嚟創建對象，代碼如下所示。

```python
stu1 = Student()
stu2 = Student()
print(stu1)    # <__main__.Student object at 0x10ad5ac50>
print(stu2)    # <__main__.Student object at 0x10ad5acd0> 
print(hex(id(stu1)), hex(id(stu2)))    # 0x10ad5ac50 0x10ad5acd0
```

喺類嘅名字後跟上圓括號就係所謂嘅構造器語法，上面嘅代碼創建咗兩個學生對象，一個賦值畀變數`stu1`，一個賦值畀變數`stu2`。當我哋用`print`函數打印`stu1`同`stu2`兩個變數時，我哋會睇到輸出咗對象喺內存中嘅地址（十六進制形式），同我哋用`id`函數查看對象標識獲得嘅值係相同嘅。而家我哋可以告訴大家，我哋定義嘅變數其實保存嘅係一個對象喺內存中嘅邏輯地址（位置），透過呢個邏輯地址，我哋就可以喺內存中搵到呢個對象。所以`stu3 = stu2`咁樣嘅賦值語句並冇創建新嘅對象，只係用一個新嘅變數保存咗已有對象嘅地址。

接下來，我哋嘗試畀對象發消息，即調用對象嘅方法。剛才嘅`Student`類中我哋定義咗`study`同`play`兩個方法，兩個方法嘅第一個參數`self`代表咗接收消息嘅學生對象，`study`方法嘅第二個參數係學習嘅課程名稱。Python中，畀對象發消息有兩種方式，請睇下下面嘅代碼。

```python
# 透過「類.方法」調用方法
# 第一個參數係接收消息嘅對象
# 第二個參數係學習嘅課程名稱
Student.study(stu1, 'Python程式設計')    # 學生正在學習Python程式設計.
# 透過「對象.方法」調用方法
# 點前面嘅對象就係接收消息嘅對象
# 只需傳入第二個參數課程名稱
stu1.study('Python程式設計')             # 學生正在學習Python程式設計.

Student.play(stu2)                      # 學生正在玩遊戲.
stu2.play()                             # 學生正在玩遊戲. 
```

### 初始化方法

大家可能已經注意到咗，剛才我哋創建嘅學生對象只有行為冇屬性，如果需要畀學生對象定義屬性，我哋可以修改`Student`類，為佢添加一個名為`__init__`嘅方法。喺我哋調用`Student`類嘅構造器創建對象時，首先會喺內存中獲得保存學生對象所需嘅內存空間，然後透過自動執行`__init__`方法，完成對內存嘅初始化操作，亦即係將數據放到內存空間中。所以我哋可以透過畀`Student`類添加`__init__`方法嘅方式為學生對象指定屬性，同時完成對屬性賦初始值嘅操作，正因如此，`__init__`方法通常都被稱為初始化方法。

我哋對上面嘅`Student`類稍作修改，畀學生對象添加`name`（姓名）同`age`（年齡）兩個屬性。

```python
class Student:
    """學生"""

    def __init__(self, name, age):
        """初始化方法
        :param name: 姓名
        :param age: 年齡
        """
        self.name = name
        self.age = age

    def study(self, course_name):
        """學習"""
        print(f'{self.name}正在學習{course_name}.')

    def play(self):
        """玩耍"""
        print(f'{self.name}正在玩遊戲.')
```

修改剛才創建對象同畀對象發消息嘅代碼，重新執行一次，睇下程式嘅執行結果有咩變化。

```python
# 調用Student類嘅構造器創建對象並傳入初始化參數
stu1 = Student('駱昊', 44)
stu2 = Student('王大錘', 25)
stu1.study('Python程式設計')    # 駱昊正在學習Python程式設計.
stu2.play()                    # 王大錘正在玩遊戲.
```


### 面向對象嘅支柱

面向對象編程有三大支柱，就係我哋之前畀大家劃重點嘅時候圈出嘅三個詞：**封裝**、**繼承**同**多態**。後面兩個概念喺下一節課中會詳細說明，呢度我哋先講下咩係封裝。我自己對封裝嘅理解係：**隱藏一切可以隱藏嘅實現細節，只向外界暴露簡單嘅調用接口**。我哋喺類中定義嘅對象方法其實就係一種封裝，呢種封裝可以讓我哋喺創建對象之後，只需要畀對象發送一個消息就可以執行方法中嘅代碼，亦即係話我哋喺只知道方法嘅名字同參數（方法嘅外部視圖），唔知道方法內部實現細節（方法嘅內部視圖）嘅情況下就完成咗對方法嘅使用。

舉一個例子，假如要控制一個機械人幫我倒杯水，如果唔使用面向對象編程，唔做任何嘅封裝，咁就需要向呢個機械人發出一系列嘅指令，如站起來、向左轉、向前走5步、拿起面前嘅水杯、向後轉、向前走10步、彎腰、放下水杯、按下出水按鈕、等待10秒、鬆開出水按鈕、拿起水杯、向右轉、向前走5步、放下水杯等，先可以完成呢個簡單嘅操作，諗下都覺得麻煩。按照面向對象編程嘅思想，我哋可以將倒水嘅操作封裝到機械人嘅一個方法中，當需要機械人幫我哋倒水嘅時候，只需要向機械人對象發出倒水嘅消息就得啦，咁樣做唔係更好咩？

喺好多場景下，面向對象編程其實就係一個三步走嘅問題。第一步定義類，第二步創建對象，第三步畀對象發消息。當然，有時我哋係唔需要第一步嘅，因為我哋想用嘅類可能已經存在啦。之前我哋講過，Python內置嘅`list`、`set`、`dict`其實都係類，如果需要創建列表、集合、字典對象，我哋就唔使自定義類啦。當然，有啲類並唔係 Python 標準庫中直接提供嘅，佢可能嚟自第三方嘅代碼，點樣安裝同使用第三方代碼喺後續課程中會進行討論。喺某啲特殊嘅場景中，我哋會用到名為「內置對象」嘅對象，所謂「內置對象」就係話上面三步走嘅第一步同第二步都唔需要啦，因為類已經存在而且對象已經創建過啦，直接向對象發消息就得啦，呢亦都係我哋常講嘅「開箱即用」。

### 面向對象案例

#### 例子1：時鐘

> **要求**：定義一個類描述數字時鐘，提供走字同顯示時間嘅功能。

```python
import time


# 定義時鐘類
class Clock:
    """數字時鐘"""

    def __init__(self, hour=0, minute=0, second=0):
        """初始化方法
        :param hour: 時
        :param minute: 分
        :param second: 秒
        """
        self.hour = hour
        self.min = minute
        self.sec = second

    def run(self):
        """走字"""
        self.sec += 1
        if self.sec == 60:
            self.sec = 0
            self.min += 1
            if self.min == 60:
                self.min = 0
                self.hour += 1
                if self.hour == 24:
                    self.hour = 0

    def show(self):
        """顯示時間"""
        return f'{self.hour:0>2d}:{self.min:0>2d}:{self.sec:0>2d}'


# 創建時鐘對象
clock = Clock(23, 59, 58)
while True:
    # 畀時鐘對象發消息讀取時間
    print(clock.show())
    # 休眠1秒鐘
    time.sleep(1)
    # 畀時鐘對象發消息使其走字
    clock.run()
```

#### 例子2：平面上嘅點

>  **要求**：定義一個類描述平面上嘅點，提供計算到另一個點距離嘅方法。

```python
class Point:
    """平面上嘅點"""

    def __init__(self, x=0, y=0):
        """初始化方法
        :param x: 橫坐標
        :param y: 縱坐標
        """
        self.x, self.y = x, y

    def distance_to(self, other):
        """計算與另一個點嘅距離
        :param other: 另一個點
        """
        dx = self.x - other.x
        dy = self.y - other.y
        return (dx * dx + dy * dy) ** 0.5

    def __str__(self):
        return f'({self.x}, {self.y})'


p1 = Point(3, 5)
p2 = Point(6, 9)
print(p1)  # 調用對象嘅__str__魔法方法
print(p2)
print(p1.distance_to(p2))
```

### 總結

面向對象編程係一種非常流行嘅編程範式，除此之外仲有**指令式編程**、**函數式編程**等編程範式。由於現實世界係由對象構成嘅，而對象係可以接收消息嘅實體，所以**面向對象編程更符合人類正常嘅思維習慣**。類係抽象嘅，對象係具體嘅，有咗類就能創建對象，有咗對象就可以接收消息，呢就係面向對象編程嘅基礎。定義類嘅過程係一個抽象嘅過程，搵到對象公共嘅屬性屬於數據抽象，搵到對象公共嘅方法屬於行為抽象。抽象嘅過程係一個仁者見仁智者見智嘅過程，對同一類對象進行抽象可能會有唔同嘅結果，如下圖所示。

<img src="res/day18/20210731182914.png" width="75%">

> **說明：** 本節課嘅插圖嚟自 Grady Booc 等撰寫嘅《面向對象分析與設計》一書，該書係講解面向對象編程嘅經典著作，有興趣嘅讀者可以購買同閱讀呢本書嚟了解更多嘅面向對象嘅相關知識。

